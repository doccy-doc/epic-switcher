#!/usr/bin/env bash

# EGSwitcher - A lightweight Bash utility for managing multiple Epic Games accounts on Linux/Wine.
# Copyright (C) 2025 doccy-doc
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/gpl-3.0.html>.
# SPDX-License-Identifier: GPL-3.0-only

set -euo pipefail

PROG_NAME=$(basename -- "$0")
VERSION="0.1.0"

die() { echo "ERROR: $*" >&2; exit 1; }
warn() { echo "WARNING: $*" >&2; }
info() { echo "INFO: $*"; }
success() { echo "SUCCESS: $*"; }
debug() { [[ "${MYSCRIPT_DEBUG:-0}" = "1" ]] && echo "DEBUG: $*" >&2; }

# =========================
# DEPENDENCIES
# =========================

check_deps() {
    local dep=$1
    command -v "$dep" &>/dev/null || die "Missing dependency: ${dep} not installed"
}

check_deps "wine"
check_deps "wineserver"
check_deps "winedbg"
check_deps "rsync"

# =========================
# CONFIG
# =========================

# WINE CONFIG
# ============================================= # ========================================= #
EGS_PFX="${HOME}/Games/Lutris/epic-games-store" # <— EDIT THIS TO BE YOUR EPIC GAMES PREFIX #
# ============================================= # ========================================= #

# ====================================== #
# TODO: wine reg query to confirm prefix #
require_prefix() {
    if [[ -d "${EGS_PFX}/drive_c" ]]; then
        export WINEPREFIX="$EGS_PFX"
        export WINEDEBUG="-winediag"
    else
        die "Wine prefix not found"
    fi
}
# ====================================== #

# Detect the Wine user directory
detect_wine_user_dir() {
require_prefix
# ================================= #
# TODO: wine reg query for USERNAME #
# Fallback to heuristics on fail    #
# ================================= #

    local drive_c="$EGS_PFX/drive_c/users"
    [[ -d "$drive_c" ]] || return 1

    # Query Wine for the actual username (respects WINEUSERNAME env)
    local wine_user
    wine_user=$(wine whoami 2>/dev/null) || true
    wine_user=$(printf '%s' "$wine_user" | tr -d '\r\n')

    # Validate it exists in prefix
    if [[ -n "$wine_user" && -d "$drive_c/$wine_user" ]]; then
        printf '%s' "$wine_user"
        return 0
    fi

    # Fallback: scan for first non-system directory
    for dir in "$drive_c"/*/; do
        [[ -d "$dir" ]] || continue
        local basename
        basename=$(basename "$dir")
        [[ "$basename" == "Public" || "$basename" == "Default" ]] && continue
        printf '%s' "$basename"
        return 0
    done

    return 1
}

WINE_USER=$(detect_wine_user_dir) || die "Failed to detect Wine user directory"

# PFX STRUCTURE
# ==============
INI_FILE="GameUserSettings.ini"
ACCOUNTS_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/epic-accounts"
ACCOUNTS_FILE="${ACCOUNTS_DIR}/accounts.txt"

# ===================================== #
# TODO: wine reg query for LOCALAPPDATA #
EGS_APPDATA="${EGS_PFX}/drive_c/users/${WINE_USER}/AppData/Local/EpicGamesLauncher/Saved"
# ===================================== #

EGS_CONFIG_DIR="${EGS_APPDATA}/Config/WindowsEditor"
EGS_CONFIG_FILE="${EGS_CONFIG_DIR}/${INI_FILE}"
#EGS_DATA_DIR="${EGS_APPDATA}/Data"

# REGISTRY INFO
# ==============
EGS_REG_KEY='HKCU\Software\Epic Games\Unreal Engine\Identifiers'
EGS_REG_VALUE='AccountId'

# TIMERS
# =======
SHUTDOWN_TIMEOUT=30

# =========================
# UTIL
# =========================

# VALIDATION
# ===========
validate_account_name() {
    local name="$1"
    [[ "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]{0,62}$ ]] || die "Invalid account name: $name"
}

validate_accounts_file() {
    local marks names ids

    mkdir -p "$ACCOUNTS_DIR"
    [ -f "$ACCOUNTS_FILE" ] || : > "$ACCOUNTS_FILE"

    marks=$(grep -c '^\* ' "$ACCOUNTS_FILE" || true)
    [ "$marks" -le 1 ] || die "accounts.txt corrupted: multiple active (*) entries"

    names=$(awk '{print $2}' "$ACCOUNTS_FILE" | sort | uniq -d || true)
    [ -z "$names" ] || die "accounts.txt corrupted: duplicate account names"

    ids=$(awk '{print $3}' "$ACCOUNTS_FILE" | sort | uniq -d || true)
    [ -z "$ids" ] || die "accounts.txt corrupted: duplicate account IDs"

    awk '
        NF==0 {next}
        NF!=3 {exit 1}
        $1!="*" && $1!="-" {exit 1}
    ' "$ACCOUNTS_FILE" || die "accounts.txt corrupted: invalid line format"
}

# DATABASE ACCESS
# ================
account_by_id() {
    validate_accounts_file
    awk -v id="$1" '$3==id {print $2}' "$ACCOUNTS_FILE"
}

account_by_name() {
    validate_accounts_file
    awk -v n="$1" '$2==n {print $3}' "$ACCOUNTS_FILE"
}

account_exists() {
    validate_accounts_file
    awk -v n="$1" '$2==n {found=1} END {exit found ? 0 : 1}' "$ACCOUNTS_FILE"
}

active_account() {
    validate_accounts_file
    awk '$1=="*" {print $2}' "$ACCOUNTS_FILE"
}

construct_entry() {
    local name="$1" uuid="$2" active="$3" mark="-"
    [[ "$active" == "true" ]] && mark="*"

    printf "%s %s %s\n" "$mark" "$name" "$uuid"
}

commit_entry() {
    validate_accounts_file
    local name="$1" uuid="$2" active="${3:-'true'}" tmp="${ACCOUNTS_FILE}.tmp.$$"  line
    line=$(construct_entry "$name" "$uuid" "$active")
    [ -f "$ACCOUNTS_FILE" ] || touch "$ACCOUNTS_FILE"

    awk -v n="$name" -v L="$line" '
        BEGIN { found=0 }
        $2 == n { print L; found=1; next }
        { print }
        END { if (!found) print L }
    ' "$ACCOUNTS_FILE" > "$tmp" && mv "$tmp" "$ACCOUNTS_FILE"
}

delete_entry() {
    validate_accounts_file
    local name="$1" tmp="${ACCOUNTS_FILE}.tmp.$$"

    awk -v n="$name" '$2 != n {print}' "$ACCOUNTS_FILE" >"$tmp" || die "Failed to create temp file"
    mv -- "$tmp" "$ACCOUNTS_FILE" || die "Failed to update accounts file"
}

set_inactive() {
    validate_accounts_file
    local name="$1" uuid
    uuid="$(account_by_name "$name")"

    [[ -n "$uuid" ]] || die "Cannot disable non-existent account: '$name'"
    commit_entry "$name" "$uuid" "false"
}

set_active() {
    validate_accounts_file
    local name="$1" uuid old_name
    uuid="$(account_by_name "$name")"
    old_name="$(active_account)"

    [[ -n "$uuid" ]] || die "Cannot activate non-existent account: '$name'"
    [[ -n "$old_name" ]] && set_inactive "$old_name"
    commit_entry "$name" "$uuid" "true"
}

# FILE MANIPULATION
# ==================
save_account_files() {
    validate_accounts_file
    require_prefix
    local name="$1"
    local store="${ACCOUNTS_DIR}/${name}"

    mkdir -p "$store"
    [ -f "$EGS_CONFIG_FILE" ] || die "No $INI_FILE to save"
    rsync -a "$EGS_CONFIG_FILE" "$store/"
}

load_account_files() {
    validate_accounts_file
    require_prefix
    local name=$1
    local store="${ACCOUNTS_DIR}/${name}"

    mkdir -p "$EGS_CONFIG_DIR"
    rsync -a "${store}/${INI_FILE}" "$EGS_CONFIG_DIR/"
}

# WINE REQUESTS
# ==============
is_egs_running() {
    require_prefix

    if  winedbg --command "info proc" 2>/dev/null |
        grep -qi 'EpicGamesLauncher\.exe'; then
        info "Epic Games Launcher is running"
        return 0
    else
        info "Epic Games Launcher is not running"
        return 1
    fi
 }

kill_egs() {
    require_prefix
    local tries=15 i
    local delay=$((SHUTDOWN_TIMEOUT / tries))

    # Stage 0: nothing running
    ! is_egs_running && return 0

    # Stage 1: attempt graceful shutdown, then recheck
    info "Attempting to close Epic Games. Wait up to ${SHUTDOWN_TIMEOUT}s..."
    wine taskkill /im EpicGamesLauncher.exe /t /f &>/dev/null || true

    for ((i= 1; i<=tries; i++)); do
        sleep "$delay"
        info "Checking..."
        ! is_egs_running && return 0
    done

    # If we get here, it failed to shut down
    # Stage 2: kill wineserver
    warn "Epic Games Launcher did not exit after ${SHUTDOWN_TIMEOUT}s."
    info "Force killing wineserver. Wait up to ${SHUTDOWN_TIMEOUT}..."
    if ! timeout 5 wineserver -w &>/dev/null; then
        wineserver -k &>/dev/null || true
    fi

    for ((i=1; i<=tries; i++)); do
        sleep "$delay"
        info "Checking..."
        ! is_egs_running && return 0
    done

    die "Failed to terminate Epic Games Launcher. Aborted."
}

get_hkey_id() {
    require_prefix

    wine reg query "$EGS_REG_KEY" /v "$EGS_REG_VALUE" 2>/dev/null |
        awk '/REG_SZ/ {print $NF}' | tr -d '\r'
}

set_hkey_id() {
    require_prefix
    local uuid=${1:-}

    wine reg add "$EGS_REG_KEY" /v "$EGS_REG_VALUE" /t REG_SZ /d "$uuid" /f >/dev/null
}

# =========================
# COMMANDS
# =========================
prompt_create_unknown() {
    local uuid="$1" name ans

    read -rp "Unrecognised Epic account detected. Create new entry? [y/N] " ans
    [[ "$ans" =~ ^[Yy]$ ]] || exit 1

# =========================================== #
# TODO: Make while loop to force correct name #
    read -rp "Account name: " name
    validate_account_name "$name"
    account_exists "$name" && die "Name already exists"
# =========================================== #

    save_account_files "$name"
    commit_entry "$name" "$uuid" "true"
    set_active "$name"
    success "Created new account: $name"
}

cmd_new() {
    # Check if we have exactly 1 argument
    [[ "$#" -eq 1 ]] || die "Usage: ${PROG_NAME} new <name>"
    require_prefix
    validate_accounts_file
    local new_name="$1" old_name hkey existing ans
    old_name=$(active_account || true)
    hkey=$(get_hkey_id || true)

    validate_account_name "$new_name"
    account_exists "$new_name" && die "Name already exists"
    kill_egs

    if [[ -n "$hkey" ]]; then
        existing=$(account_by_id "$hkey" || true)
        [[ -n "$existing" ]] && save_account_files "$existing"
    fi

    [[ -n "$old_name" ]] && set_inactive "$new_name"
    [[ -n "$hkey" ]] && set_hkey_id
    rm -f "${EGS_CONFIG_FILE}"

    success "Launcher cleared. Please login to Epic Games Launcher now"
    while true; do
        read -rp "Done? [y = save / x = abort] " ans
        case "$ans" in
            y|Y)
                info "Creating new account: $new_name"
                cmd_save "$new_name"
                return
                ;;
            x|X|n|N)
                info "Aborted. Attempting to restore account: $old_name"
                kill_egs
                if [[ -n "$old_name" ]]; then
                    cmd_load "$old_name"
                    else
                    info "No previous account to load. Cleared Epic Games Launcher state"
                    exit 0
                fi
                return
                ;;
            *)
                warn "Unrecognised input: $ans. Please enter Y or X "
                ;;
        esac
    done
}

cmd_save() {
    # Check if we have ≤ 1 arguments
    [[ "$#" -le 1 ]] || die "Usage: ${PROG_NAME} save [name]"
    validate_accounts_file
    require_prefix
    local name="${1:-}" hkey active_name uuid active
    [[ -n "$name" ]] && validate_account_name "$name"
    hkey=$(get_hkey_id) || die "No Epic account logged in"
    active_name=$(account_by_id "$hkey" || true)

    # No name entered. check active account
    if [[ -z "$name" ]]; then
        info "Name not set. Resolving..."
        if [ -n "$active_name" ]; then
            info "Found existing $active_name"
            name="$active_name"
        else
            info "No existing account found. Starting wizard..."
            prompt_create_unknown "$hkey"
            return
        fi
    fi

    # Find account name
    if account_exists "$name"; then
        info "Found account. Resolving..."
        uuid=$(account_by_name "$name")
        [[ "$uuid" = "$hkey" ]] || die "Account $name exists with different ID"
    else
        info "Account $name not found."
        [[ -z "$active_name" ]] || die "Account already saved under name '$active_name'"
    fi

    # Commit
    active=$(active_account)
    save_account_files "$name"
    [[ -n "$active" ]] && [[ "$active" != "$name" ]] && set_inactive "$active"
    commit_entry "$name" "$hkey" "true"
    success "Saved account: '$name'."
}

cmd_load() {
    # Check if we have exactly 1 argument
    [[ "$#" -eq 1 ]] || die "Usage: ${PROG_NAME} load <name>"
    validate_accounts_file
    require_prefix
    local name="$1" uuid hkey active_name
    uuid=$(account_by_name "$name")
    hkey=$(get_hkey_id || true)

    validate_account_name "$name"
    account_exists "$name" || die "Account not found"
    kill_egs

    # Check for active account
    if [[ -n "$hkey" ]]; then
        active_name=$(account_by_id "$hkey" || true)
        #check if account is in list
        if account_exists "$active_name"; then
            save_account_files "$active_name"
        else
            prompt_create_unknown "$hkey"
        fi
    fi

    # Load
    set_hkey_id "$uuid"
    load_account_files "$name"
    set_active "$name"
    success "Loaded account: '$name'. You can now launch your game."
}

cmd_delete() {
    # Check if we have exactly 1 argument
    [[ "$#" -eq 1 ]] || die "Usage: ${PROG_NAME} delete <name>"
    validate_accounts_file
    local name="$1"

    validate_account_name "$name"
    account_exists "$name" || die "Account not found"

    # Check against active
    [[ "$(active_account || true)" != "$name" ]] || die "Cannot delete active account"

    # Delete
    delete_entry "$name"
    rm -rf -- "${ACCOUNTS_DIR:?}/${name}"
    success "Deleted account: $name"
}

cmd_rename() {
    # Check if we have exactly 2 arguments
    [[ "$#" -eq 2 ]] || die "Usage: ${PROG_NAME} rename <old_name> <new_name>"
    validate_accounts_file
    local old_name="$1" new_name="$2"

    validate_account_name "$new_name"
    validate_account_name "$old_name"
    account_exists "$old_name" || die "Source name $old_name not found"
    ! account_exists "$new_name" || die "Target name $new_name already exists"

    # Rename
    mv -- "${ACCOUNTS_DIR}/${old_name}" "${ACCOUNTS_DIR}/${new_name}"

# TODO: ADD FUNCTIONS delete_entry + commit_entry (with test for *) #
# Leaving atomic sed inplace as it is less prone to DB corruption.  #
# ================================================================= #
    sed -i "s/^\\([*-]\\) $old_name /\\1 $new_name /" "$ACCOUNTS_FILE"
# ================================================================= #
    success "Renamed $old_name to $new_name"
}

cmd_list() {
    validate_accounts_file

    printf "%-8s %-20s %s\n" STATUS NAME ID
    printf "%-8s %-20s %s\n" ------ ---- --
    while read -r mark name id; do
        status=$([ "$mark" = "*" ] && echo ACTIVE || echo "")
        printf "%-8s %-20s %s\n" "$status" "$name" "${id: 0:4}...${id: -4:4}"
    done <"$ACCOUNTS_FILE"
}

cmd_help() {
        cat <<EOF

Commands:
  new <name>          Create a new account with name <name>
                      Example: $PROG_NAME new MyAccount

  save [name]         Save the current account. Optionally specify <name>
                      If specified <name> does not exist, a new account will be created
                      Examples:
                        $PROG_NAME save                 # Save current account using existing active name
                        $PROG_NAME save ExistingAccount # Same as: $PROG_NAME save
                        $PROG_NAME save NewAccount      # Save new account with name NewAccount

  load <name>         Load an existing account by name
                      Example: $PROG_NAME load MyAccount

  delete <name>       Delete an existing account (cannot delete the active account)
                      Example: $PROG_NAME delete MyAccount

  rename <old> <new>  Rename an account from <old> to <new>
                      Example: $PROG_NAME rename OldName NewName

  list                List all saved accounts and the currently active one
                      Example: $PROG_NAME list

EOF
}

cmd_desc(){
    cat <<EOF
EGSwitcher
A tool for swapping Epic Games accounts in the Epic Games Launcher without having to manually logout and login each time. Works on Linux with either WINE or proton
EOF
}

# =========================
# MAIN
# =========================
CMD="${1:-}"
shift || : # Discard the command name

case "$CMD" in
    new)    cmd_new "$@" ;;
    save)   cmd_save "$@" ;;
    load)   cmd_load "$@" ;;
    delete) cmd_delete "$@" ;;
    rename) cmd_rename "$@" ;;
    list)   cmd_list ;;
    -v|--version)
        echo "$VERSION"
        exit 0
    ;;
    -h|--help)
        cmd_desc
        cmd_help
        exit 0
        ;;
    *)
        if [ -n "${CMD}" ] ; then
            warn "Syntax error: command '$CMD' not recognised"
        else
            cmd_desc
        fi
        cmd_help
        exit 1
        ;;
esac
