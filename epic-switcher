#!/usr/bin/env bash
set -euo pipefail

die() { echo "ERROR: $*" >&2; exit 1; }
warn() { echo "WARNING: $*" >&2; }
info() { echo "INFO: $*"; }
success() { echo "SUCCESS: $*"; }
debug() {
[[ "${MYSCRIPT_DEBUG:-0}" = "1" ]] && echo "DEBUG: $*" >&2;
}
PROG_NAME=$(basename -- "$0")

# =========================
# DEPENDENCIES
# =========================

check_deps() {
    local cmd=$1
    command -v "$cmd" &> /dev/null || die "Missing dependency: ${cmd} not installed."
}

check_deps "wine"
check_deps "wineserver"
check_deps "winedbg"
check_deps "rsync"

# =========================
# CONFIG
# =========================

# PFX LOCATION
# =============
EGS_PFX="${HOME}/Games/Lutris/epic-games-store"

# Detect the Wine user directory
detect_wine_user_dir() {

# ================================= #
# TODO: wine reg query for USERNAME #
# Fallback to heuristics on fail    #
# ================================= #

    local drive_c="$EGS_PFX/drive_c/users"
    [[ -d "$drive_c" ]] || return 1

    # Query Wine for the actual username (respects WINEUSERNAME env)
    local wine_user
    wine_user=$(WINEPREFIX="$EGS_PFX" wine whoami 2>/dev/null) || true
    wine_user=$(printf '%s' "$wine_user" | tr -d '\r\n')

    # Validate it exists in prefix
    if [[ -n "$wine_user" && -d "$drive_c/$wine_user" ]]; then
        printf '%s' "$wine_user"
        return 0
    fi

    # Fallback: scan for first non-system directory
    for dir in "$drive_c"/*/; do
        [[ -d "$dir" ]] || continue
        local basename
        basename=$(basename "$dir")
        [[ "$basename" == "Public" || "$basename" == "Default" ]] && continue
        printf '%s' "$basename"
        return 0
    done

    return 1
}

WINE_USER=$(detect_wine_user_dir) || die "Failed to detect Wine user directory"

# PFX STRUCTURE
# ==============
INI_FILE="GameUserSettings.ini"
ACCOUNTS_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/epic-accounts"
ACCOUNTS_FILE="${ACCOUNTS_DIR}/accounts.txt"

# ===================================== #
# TODO: wine reg query for LOCALAPPDATA #
EGS_APPDATA="${EGS_PFX}/drive_c/users/${WINE_USER}/AppData/Local/EpicGamesLauncher/Saved"
# ===================================== #

EGS_CONFIG_DIR="${EGS_APPDATA}/Config/WindowsEditor"
EGS_CONFIG_FILE="${EGS_CONFIG_DIR}/${INI_FILE}"
#EGS_DATA_DIR="${EGS_APPDATA}/Data"

# REGISTRY INFO
# ==============
REG_KEY='HKCU\Software\Epic Games\Unreal Engine\Identifiers'
REG_VALUE='AccountId'
SHUTDOWN_TIMEOUT=30

# TEMP VARS
# ==========
PENDING_NEW_NAME=""
PREV_ACTIVE_NAME=""

# =========================
# UTIL
# =========================

# VALIDATION
# ===========
validate_account_name() {
    local name="$1"
    [[ "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]{0,62}$ ]] || die "Invalid account name"
}

require_prefix() {
    [ -d "${EGS_PFX}/drive_c" ] || die "Wine prefix not found"
}

ensure_accounts_file() {
    mkdir -p "$ACCOUNTS_DIR"
    [ -f "$ACCOUNTS_FILE" ] || : > "$ACCOUNTS_FILE"
}

validate_accounts_file() {
    ensure_accounts_file

    local stars names ids
    stars=$(grep -c '^\* ' "$ACCOUNTS_FILE" || true)
    [ "$stars" -le 1 ] || die "accounts.txt corrupted: multiple active (*) entries"

    names=$(awk '{print $2}' "$ACCOUNTS_FILE" | sort | uniq -d || true)
    [ -z "$names" ] || die "accounts.txt corrupted: duplicate account names"

    ids=$(awk '{print $3}' "$ACCOUNTS_FILE" | sort | uniq -d || true)
    [ -z "$ids" ] || die "accounts.txt corrupted: duplicate account IDs"

    awk '
        NF==0 {next}
        NF!=3 {exit 1}
        $1!="*" && $1!="-" {exit 1}
    ' "$ACCOUNTS_FILE" || die "accounts.txt corrupted: invalid line format"
}

# DATABASE ACCESS
# ================
account_by_id() {
    validate_accounts_file
    awk -v id="$1" '$3==id {print $2}' "$ACCOUNTS_FILE"
}

account_by_name() {
    validate_accounts_file
    awk -v n="$1" '$2==n {print $3}' "$ACCOUNTS_FILE"
}

account_exists() {
    validate_accounts_file
    awk -v n="$1" '$2==n {found=1} END {exit found ? 0 : 1}' "$ACCOUNTS_FILE"
}

active_account() {
    validate_accounts_file
    awk '$1=="*" {print $2}' "$ACCOUNTS_FILE"
}

construct_entry() {
    local name="$1" uuid="$2" active="$3"
    local mark="-"
    [[ "$active" == "true" ]] && mark="*"
    printf "%s %s %s\n" "$mark" "$name" "$uuid"
}

commit_entry() {
    validate_accounts_file
    local name="$1" uuid="$2" active="${3:-'true'}"
    local line
    line=$(construct_entry "$name" "$uuid" "$active")
    local tmp="${ACCOUNTS_FILE}.tmp.$$"
    [ -f "$ACCOUNTS_FILE" ] || touch "$ACCOUNTS_FILE"

    awk -v n="$name" -v L="$line" '
        BEGIN { found=0 }
        $2 == n { print L; found=1; next }
        { print }
        END { if (!found) print L }
    ' "$ACCOUNTS_FILE" > "$tmp" && mv "$tmp" "$ACCOUNTS_FILE"
}

delete_entry() {
    validate_accounts_file
    local name="$1"

    local tmp="${ACCOUNTS_FILE}.tmp.$$"
    awk -v n="$name" '$2 != n {print}' "$ACCOUNTS_FILE" >"$tmp" || die "Failed to create temp file"
    mv -- "$tmp" "$ACCOUNTS_FILE" || die "Failed to update accounts file"
}

set_inactive() {
    validate_accounts_file
    local name="$1" uuid
    uuid="$(account_by_name "$name")"
    [[ -n "$uuid" ]] || die "Cannot disable non-existent account: '$name'"
    commit_entry "$name" "$uuid" "false"
}

set_active() {
    validate_accounts_file
    local name="$1" uuid old
    old=$(active_account)
    uuid="$(account_by_name "$name")"
    [[ -n "$uuid" ]] || die "Cannot activate non-existent account: '$name'"
    [[ -n "$old" ]] && set_inactive "$old"
    commit_entry "$name" "$uuid" "true"
}

# FILE MANIPULATION
# ==================
save_account_files() {
    local name="$1"
    local store="${ACCOUNTS_DIR}/${name}"

    validate_accounts_file
    require_prefix

    mkdir -p "$store"
    [ -f "$EGS_CONFIG_FILE" ] || die "No $INI_FILE to save"
    rsync -a "$EGS_CONFIG_FILE" "$store/"
}

load_account_files() {
    local name=$1
    local store="${ACCOUNTS_DIR}/${name}"

    validate_accounts_file
    require_prefix

    mkdir -p "$EGS_CONFIG_DIR"
    rsync -a "${store}/${INI_FILE}" "$EGS_CONFIG_DIR/"
}

# WINE REQUESTS
# ==============
is_egs_running() {
    require_prefix
    export WINEDEBUG=-winediag
    if  WINEPREFIX="$EGS_PFX" winedbg --command "info proc" 2>/dev/null |
        grep -qi 'EpicGamesLauncher\.exe'; then
        info "Epic Games Launcher is running"
        return 0
    else
        info "Epic Games Launcher is not running"
        return 1
    fi
 }

kill_egs() {
    require_prefix

    # Stage 0: nothing running
    ! is_egs_running && return 0

    # Stage 1: attempt graceful shutdown, then recheck
    info "Attempting to close Epic Games. Wait up to ${SHUTDOWN_TIMEOUT}s..."

    local tries=3
    local delay=$((SHUTDOWN_TIMEOUT / tries))

    WINEPREFIX="$EGS_PFX" wine taskkill /im EpicGamesLauncher.exe /t /f >/dev/null 2>&1 || true

    for ((i= 1; i<=tries; i++)); do
        sleep "$delay"
        info "Checking..."
        ! is_egs_running && return 0
    done

    # If we get here, it failed to shut down
    # Stage 2: wineserver wait
    warn "Epic Games Launcher did not exit after ${SHUTDOWN_TIMEOUT}s."
    info "Force killing wineserver. Wait up to ${SHUTDOWN_TIMEOUT}..."
    if ! timeout "$SHUTDOWN_TIMEOUT" WINEPREFIX="$EGS_PFX" wineserver -w >/dev/null 2>&1; then
        WINEPREFIX="$EGS_PFX" wineserver -k >/dev/null 2>&1 || true
    fi

    for ((i=1; i<=tries; i++)); do
        sleep "$delay"
        info "Checking..."
        ! is_egs_running && return 0
    done

# ====================================== #
# REMOVED DUE TO UNPREDICTABLE BEHAVIOUR #
# ====================================== #
#     # Stage 3: nuclear pkill
#     while true; do
#         warn "WINE prefix did not exit after ${SHUTDOWN_TIMEOUT}s. Nuclear fallback recommended."
#         warn "This will terminate ALL RUNNING PREFIXES. Any unsaved changes will be lost."
#         read -rp "Are you sure? [y/N] " ans
#         case "$ans" in
#             y|Y)
#                 info "Attempting to kill all WINE processes"
#                 pkill -9 -f "wineserver" 2>/dev/null || true
#                 pkill -9 -f ".exe" 2>/dev/null || true
#                 break
#                 ;;
#             x|X|n|N)
#                 die "Aborted. Please quit Epic Games Launcher manually."
#                 ;;
#             *)
#                 warn "Unrecognised input: $ans. Please enter Y or N."
#                 ;;
#         esac
#     done
#
#     for ((i=1; i<=tries; i++)); do
#         sleep "$delay"
#         info "Checking..."
#         ! is_egs_running && return 0
#     done

    die "Failed to terminate Epic Games Launcher. Aborted."
}

get_hkey_id() {
    require_prefix
    WINEPREFIX="$EGS_PFX" wine reg query "$REG_KEY" /v "$REG_VALUE" 2>/dev/null |
        awk '/REG_SZ/ {print $NF}' | tr -d '\r'
}

set_hkey_id() {
    require_prefix
    local id=${1:-}
    WINEPREFIX="$EGS_PFX" wine reg add "$REG_KEY" /v "$REG_VALUE" /t REG_SZ /d "$id" /f >/dev/null
}

# =========================
# COMMANDS
# =========================
prompt_create_unknown() {
    local id="$1"
    read -rp "Unrecognised Epic account detected. Create new entry? [y/N] " ans
    [[ "$ans" =~ ^[Yy]$ ]] || exit 1
    read -rp "Account name: " name
    validate_account_name "$name"
    account_exists "$name" && die "Name already exists"
    save_account_files "$name"
    commit_entry "$name" "$id" "true"
    set_active "$name"

    success "Created new account: $name"
}

cmd_new() {
    # Check if we have exactly 1 argument
    [ "$#" -eq 1 ] || die "Usage: ${PROG_NAME} new <name>"

    local name="$1"
    require_prefix
    validate_accounts_file
    validate_account_name "$name"
    account_exists "$name" && die "Name already exists"

    kill_egs

    local hkey
    hkey=$(get_hkey_id || true)

    PREV_ACTIVE_NAME=$(active_account || true)
    PENDING_NEW_NAME="$name"

    if [ -n "$hkey" ]; then
        local existing
        existing=$(account_by_id "$hkey" || true)
        [ -n "$existing" ] && save_account_files "$existing"
    fi

    [[ -n "$PREV_ACTIVE_NAME" ]] && set_inactive "$PREV_ACTIVE_NAME"
    [[ -n "$hkey" ]] && set_hkey_id
    rm -f "${EGS_CONFIG_FILE}"

    success "Launcher cleared. Please login to Epic Games Launcher now."
    while true; do
        read -rp "Done? [y = save / x = abort] " ans
        case "$ans" in
            y|Y)
                info "Creating new account: $PENDING_NEW_NAME"
                cmd_save "$PENDING_NEW_NAME"
                return
                ;;
            x|X|n|N)
                info "Aborted. Attempting to restore account: $PREV_ACTIVE_NAME"
                kill_egs
                if [ -n "$PREV_ACTIVE_NAME" ]; then
                    cmd_load "$PREV_ACTIVE_NAME"
                    else
                    info "No previous account to load. Cleared Epic Games Launcher state"
                    exit 0
                fi
                return
                ;;
            *)
                warn "Unrecognised input: $ans. Please enter Y or X."
                ;;
        esac
    done
}

cmd_save() {
    # Check if we have â‰¤ 1 arguments
    [ "$#" -le 1 ] || die "Usage: ${PROG_NAME} save [name]"

    local name="${1:-}"
    require_prefix
    validate_accounts_file
    [ -n "$name" ] && validate_account_name "$name"

    local hkey
    hkey=$(get_hkey_id) || die "No Epic account logged in"
    local existing_name
    existing_name=$(account_by_id "$hkey" || true)

    # Resolve Name
    if [ -z "$name" ]; then
        info "Name not set. Resolving..."
        if [ -n "$existing_name" ]; then
            info "Found existing $existing_name"
            name="$existing_name"
        else
            info "No existing found. Starting wizard..."
            prompt_create_unknown "$hkey"
            return
        fi
    fi

    # Validate
    if account_exists "$name"; then
        info "Found account. Resolving..."
        local id
        id=$(account_by_name "$name")
        [ "$id" = "$hkey" ] || die "Account $name exists with different ID"
    else
        info "Account not found."
        [ -z "$existing_name" ] || die "Account already saved under name '$existing_name'"
    fi

    # Commit
    local active
    active=$(active_account)
    save_account_files "$name"
    [[ -n "$active" ]] && [[ "$active" != "$name" ]] && set_inactive "$active"
    commit_entry "$name" "$hkey" "true"
    success "Saved account: '$name'."
}

cmd_load() {
    # Check if we have exactly 1 argument
    [ "$#" -eq 1 ] || die "Usage: ${PROG_NAME} load <name>"

    local name="$1"
    validate_accounts_file
    validate_account_name "$name"
    account_exists "$name" || die "Account not found"
    require_prefix

    kill_egs

    local hkey
    hkey=$(get_hkey_id || true)

    if [ -n "$hkey" ]; then
        local outgoing
        outgoing=$(account_by_id "$hkey" || true)
        #check if account is in list
        if account_exists "$outgoing"; then
            save_account_files "$outgoing"
        else
            prompt_create_unknown "$hkey"
        fi
    fi

    local id
    id=$(account_by_name "$name")

    set_hkey_id "$id"
    load_account_files "$name"

    set_active "$name"
    success "Loaded account: '$name'. You can now launch your game."
}

cmd_delete() {
    # Check if we have exactly 1 argument
    [ "$#" -eq 1 ] || die "Usage: ${PROG_NAME} delete <name>"

    local name="$1"
    validate_accounts_file
    validate_account_name "$name"
    account_exists "$name" || die "Account not found"

    [ "$(active_account || true)" != "$name" ] || die "Cannot delete active account"

    delete_entry "$name"
    rm -rf -- "${ACCOUNTS_DIR:?}/${name}"

    success "Deleted account: $name"

}

cmd_rename() {
    # Check if we have exactly 2 arguments
    [ "$#" -eq 2 ] || die "Usage: ${PROG_NAME} rename <old_name> <new_name>"

    local old="$1" new="$2"
    validate_accounts_file
    validate_account_name "$new"
    account_exists "$old" || die "Source name not found"
    ! account_exists "$new" || die "Target name already exists"

    mv -- "${ACCOUNTS_DIR}/${old}" "${ACCOUNTS_DIR}/${new}"

# TODO: ADD FUNCTIONS delete_entry + commit_entry (with test for *) #
# Leaving atomic sed inplace as it is less prone to DB corruption.  #
# ================================================================= #
    sed -i "s/^\\([*-]\\) $old /\\1 $new /" "$ACCOUNTS_FILE"
# ================================================================= #
    success "Renamed $old to $new"
}

cmd_list() {
    validate_accounts_file
    printf "%-8s %-20s %s\n" STATUS NAME ID
    printf "%-8s %-20s %s\n" ------ ---- --
    while read -r mark name id; do
        status=$([ "$mark" = "*" ] && echo ACTIVE || echo "")
        printf "%-8s %-20s %s\n" "$status" "$name" "${id: 0:4}...${id: -4:4}"
    done <"$ACCOUNTS_FILE"
}

cmd_help() {
        cat <<EOF

Commands:
  new <name>          Create a new account with name <name>.
                      Example: $PROG_NAME new MyAccount

  save [name]         Save the current account. Optionally specify <name>.
                      If specified <name> does not exist, a new account will be created.
                      Examples:
                        $PROG_NAME save                 # Save current account using existing active name
                        $PROG_NAME save ExistingAccount # Same as: $PROG_NAME save
                        $PROG_NAME save NewAccount      # Save new account with name NewAccount

  load <name>         Load an existing account by name.
                      Example: $PROG_NAME load MyAccount

  delete <name>       Delete an existing account (cannot delete the active account).
                      Example: $PROG_NAME delete MyAccount

  rename <old> <new>  Rename an account from <old> to <new>.
                      Example: $PROG_NAME rename OldName NewName

  list                List all saved accounts and the currently active one.
                      Example: $PROG_NAME list

EOF
}

cmd_desc(){
    cat <<EOF
Epic Games Account Switcher.
A tool for swapping Epic Games accounts in the Epic Games Launcher without having to manually logout and login each time. Works on Linux with either WINE or proton.
EOF
}

# =========================
# MAIN
# =========================
CMD="${1:-}"
shift || : # Discard the command name

case "$CMD" in
    new)    cmd_new "$@" ;;
    save)   cmd_save "$@" ;;
    load)   cmd_load "$@" ;;
    delete) cmd_delete "$@" ;;
    rename) cmd_rename "$@" ;;
    list)   cmd_list ;;
    -h|--help)
        cmd_desc
        cmd_help
        exit 0
        ;;
    *)
        if [ -n "${CMD}" ] ; then
            warn "Syntax error: command '$CMD' not recognised."
        else
            cmd_desc
        fi
        cmd_help
        exit 1
        ;;
esac
